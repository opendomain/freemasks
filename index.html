<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Cube: Find Groups</title>
    <script>
        "use strict";

        //const _numScreens = 6;
        const _numCols = 4;
        const _numRows = 2;

        const _numRotations = 4;

        const _numPiecesInStamp = 4;

        var _cubeWorld;
        var _baseCopy;
        var _backCopy;

        const _xOffset = 5;
        const _yOffset = 5;
        const _size = 90;
        const _half = Math.ceil(_size / 2);
        const _cubeSpace = 5;
        const _lineWidth = 1;

        var _maxSearchNonBlankFace = 1;

        const TRIANGLE_BITS = {
            "North": 0x01,
            "East": 0x02,
            "South": 0x04,
            "West": 0x08
        };

        const TRIANGLE_POS = {
            "NotSet": -1,
            "North": 0,
            "East": 1,
            "South": 2,
            "West": 3
        };

        const _faceColors = [
            "gray",
            "green",
            "maroon",
            "navy",
            "olive",
            "orange",
            "silver",
            "teal",
            //
            "aqua",
            "black",
            "blue",
            "lime",
            "white",
            "yellow",
            "fuchsia",
            "purple",
            "red",
        ];

        const _faceNumbers = {
            "Front": 4,
            "Left": 1,
            "Right": 0,
            "Top": 2,
            "Bottom": 3,
            "Back": 5
        };

        const _numFaceColors = _faceColors.length;

        const _goodFaces = {
            "blank": 0,
            "triangle_topLeft": 1,
            "triangle_topRight": 2,
            "triangle_bottomRight": 3,
            "triangle_bottomLeft": 4,
            "block": 5,
            "rectangle_left": 6,
            "rectangle_top": 7,
            "rectangle_right": 8,
            "rectangle_bottom": 9,
        };

        const _numGoodFaces = Object.keys(_goodFaces).length;

        const _triangleName = {
            "blank": 0,
            "topRight": 1,
            "bottomRight": 2,
            "bottomLeft": 3,
            "topLeft": 4,
            "block": 5
        };

        const _numStampsInRowOrCol = 2;

        var _mainScreen;

        function init() {
            getCanvas();

            var elemRotate = document.getElementById("selNumRotate");
            _maxSearchNonBlankFace = elemRotate.options[elemRotate.selectedIndex].value;

            _baseCopy = clone(_baseset);
            _backCopy = clone(_baseset);

            //_cubeWorld = new CubeWorld();
            //let screen = _cubeWorld.getScreen(screenNum);
            //loadScreen(screen, _numCols, _numRows);

            let screenId = 0;
            _mainScreen = new Screen(screenId, _numCols, _numRows);

            loadScreen(_mainScreen);

            var elemOutout = document.getElementById("txtScreenData");
            elemOutout.value = JSON.stringify(_mainScreen);

            _mainScreen.display(false);
        }

        function clone(objIn) {
            if (!objIn) {
                alert('Invalid Clone - In');
            }

            let objInStr = JSON.stringify(objIn);
            var newObj = JSON.parse(objInStr);

            if (!newObj) {
                alert('Invalid Clone - Out');
            }
            return newObj;
        }

        var _numMsg = 0;
        var _MAX_NUM_MSG = 3;
        var _lastsMsg = "";
        function log(msg) {
            if (msg == _lastsMsg) return;
            _lastsMsg = msg;
            if (_numMsg <= _MAX_NUM_MSG) {
                _numMsg++;
                alert(msg);
            }
            console.log(msg);
        }

        function CubeWorld(numScreens) {
            numScreens = numScreens || _numScreens;
            let screens = [];

            for (let s = 0; s < numScreens; s++) {
                let newScreen = new Screen(s);
                screens.push(newScreen);
            }

            this.getScreen = function (screenNum) {
                return screens[screenNum];
            }

            return this;
        }

        function Screen(id, width, height) {
            let screen = {
                width: undefined,
                height: undefined,
            };

            this.id = id;
            this.screenFaces = [];

            this.init = function (width, height) {
                screen.width = width;
                screen.height = height;

                let newFaces = [];

                for (let r = 0; r < screen.height; r++) {
                    let newRow = [];
                    for (let c = 0; c < screen.width; c++) {
                        let newFace = new Face(c, r);
                        newRow.push(newFace);
                    }
                    newFaces.push(newRow);
                }

                this.screenFaces = newFaces;
            };

            this.getWidth = function () {
                return (screen.width);
            };

            this.getHeight = function () {
                return (screen.height);
            };

            this.getFace = function (col, row) {
                let faceRow = this.screenFaces[row];
                if (!faceRow) {
                    alert('Invalid Face row');
                }
                let fce = faceRow[col];
                if (!fce) {
                    alert('Invalid Face col');
                }
                return fce;
            };

            this.display = function (showSecondColor) {
                let triangleString;
                let triangleStringBack;
                let centerPoint;

                let lineColorOutline = "black";
                let fillColorOutline = "";

                let lineColor = "white";
                let fillColor = "green";

                let outlinePoints;
                let trianglePoints;
                let trianglePointsBack;
                let useBack = true;

                for (let row = 0; row < screen.height; row++) {
                    for (let col = 0; col < screen.width; col++) {
                        let face = this.getFace(col, row);
                        for (let x = 0; x < _numStampsInRowOrCol; x++) {
                            for (let y = 0; y < _numStampsInRowOrCol; y++) {
                                centerPoint = calculateCenterPoint(col, row, x, y);

                                outlinePoints = makeOutlinePoints(centerPoint);

                                drawShape(outlinePoints, lineColorOutline, fillColorOutline, _ctx);
                                drawShape(outlinePoints, lineColorOutline, fillColorOutline, _ctx2);

                                //let stampNum = face.getStampNum(x, y);
                                //triangleString = getTriangleString(stampNum);

                                triangleString = face.getTriangles(x, y);
                                trianglePoints = makeTrianglePoints(triangleString, centerPoint);

                                triangleStringBack = face.getTriangles(x, y, useBack);
                                trianglePointsBack = makeTrianglePoints(triangleStringBack, centerPoint);

                                fillColor = face.color;
                                if (showSecondColor) {
                                    // Zedric use piece num
                                    for (let p = 0; p < _numPiecesInStamp; p++) {
                                        fillColor = face.getPieceColor(x, y, p);
                                        if (fillColor != "black") break;
                                    }
                                }
                                drawShape(trianglePoints, lineColor, fillColor, _ctx);

                                fillColor = face.backColor;
                                if (showSecondColor) {
                                    // Zedric use piece num
                                    for (let p = 0; p < _numPiecesInStamp; p++) {
                                        fillColor = face.getPieceColor(x, y, p, useBack);
                                        if (fillColor != "black") break;
                                    }
                                }
                                drawShape(trianglePointsBack, lineColor, fillColor, _ctx2);

                            }
                        }
                    }
                }
            }

            this.init(width, height);

            return this;
        }

        function Face(col, row) {
            this.col = col;
            this.row = row;
            this.color = undefined;
            this.backColor = undefined;

            this.cubeOrder = -1;
            this.cubeFaceId = -1;
            this.cubeRotation = -1;

            let face = {
                stamps: [],
                backStamps: []
            };


            function getStamp(x, y, useBack) {
                let stampRow = face.stamps[y];
                if (useBack) {
                    stampRow = face.backStamps[y];
                } 

                if (!stampRow) {
                    alert('Invalid stampRow');
                }
                let stmp = stampRow[x];
                if (!stmp) {
                    alert("Invalid getStamp");
                }
                return stmp;
            }

            this.init = function () {
                let newStamps = [];
                let newBackStamps = [];
                for (let r = 0; r < _numStampsInRowOrCol; r++) {
                    let newRow = [];
                    let newBackRow = [];
                    for (let c = 0; c < _numStampsInRowOrCol; c++) {
                        let newStamp = new Stamp(c, r);
                        newRow.push(newStamp);

                        let newBackStamp = new Stamp(c, r);
                        newBackRow.push(newBackStamp);
                    }
                    newStamps.push(newRow);
                    newBackStamps.push(newBackRow);
                }
                face.stamps = newStamps;
                face.backStamps = newBackStamps;
            };

            this.getStampNum = function (x, y, useBack) {
                let stmp = getStamp(x, y, useBack);
                return stmp.stampNum;
            };

            this.setStampNum = function (x, y, num, useBack) {
                if (typeof (num) != 'number') log('Invalid stampNum');
                let stmp = getStamp(x, y, useBack);
                stmp.stampNum = num;
                stmp.triangles = getTriangleString(num);
            };

            this.getTriangles = function (x, y, useBack) {
                let stmp = getStamp(x, y, useBack);
                return stmp.triangles;
            };

            this.getStampVisited = function (x, y, p, useBack) {
                let stmp = getStamp(x, y, useBack);
                let piece = stmp.pieces[p];
                return piece.visited;
            };

            this.setStampVisited = function (x, y, p, visited, useBack) {
                if (typeof (visited) != 'boolean') log('Invalid visited type');
                let stmp = getStamp(x, y, useBack);
                let piece = stmp.pieces[p];
                piece.visited = visited;
            };

            this.getPieceColor = function (x, y, p, useBack) {
                let stmp = getStamp(x, y, useBack);
                let piece = stmp.pieces[p];
                let color = piece.color;
                return color;
            };

            this.setPieceColor = function (x, y, p, color, useBack) {
                let stmp = getStamp(x, y, useBack);
                let piece = stmp.pieces[p];
                piece.color = color;
            }

            this.init();

            return this;
        }

        function Stamp(x, y) {
            this.x = x;
            this.y = y;
            this.pieces = [];
            this.stampNum = undefined;
            this.triangles = "";

            this.init = function () {
                this.pieces = [];
                for (let p = 0; p < _numPiecesInStamp; p++) {
                    let newPiece = new Piece(p);
                    this.pieces.push(newPiece);
                }
            };

            this.init();

            return this;
        }

        function Piece(num) {
            this.pieceNum = num;
            //this.isOn = false;
            this.visited = undefined;
            this.color = "black";
            return this;
        }

        function loadScreen(screen) {
            let faceNum = 0;
            let numCubes;
            let randCubeNum;
            let cube;
            let numFaces;
            let faceStampNum;
            let faceStampBackNum;
            let rotation;

            let faceColorNum;
            let faceColor;

            let cubeFrontFace;
            let cubeFaceFrontImage;
            let cubeBackFaceNum;
            let cubeBackFace;
            let cubeFaceBackImage;

            let useBack = true;

            let numCols = screen.getWidth();
            let numRows = screen.getHeight();

            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {
                    let face = screen.getFace(col, row);

                    numCubes = _baseCopy.cubes.length;
                    randCubeNum = Math.floor(Math.random() * numCubes);
                    cube = _baseCopy.cubes.splice(randCubeNum, 1)[0];

                    numFaces = cube.faces.length;
                    faceNum = Math.floor(Math.random() * numFaces);
                    let numSearchNonBlankFace = 0;
                    let faceNumMod = 0;
                    do {
                        faceNumMod = (faceNum + numSearchNonBlankFace) % numFaces;
                        cubeFrontFace = cube.faces[faceNumMod];
                        cubeFaceFrontImage = cubeFrontFace.image;

                        cubeBackFaceNum = getBackFace(faceNumMod);
                        cubeBackFace = cube.faces[cubeBackFaceNum];
                        cubeFaceBackImage = cubeBackFace.image;

                        if ((cubeFaceFrontImage != "blank") && (cubeFaceBackImage != "blank") )  {
                            break;
                        }
                        numSearchNonBlankFace++;
                    } while (numSearchNonBlankFace < _maxSearchNonBlankFace);

                    //faceColorNum = Math.floor(Math.random() * _numFaceColors);
                    //faceColor = _faceColors[faceColorNum];
                    //face.color = faceColor;
                    face.color = cubeFrontFace.color;
                    face.backColor = cubeBackFace.color;

                    let randRotation = Math.floor(Math.random() * _numRotations) * 90;

                    rotation = (cubeFrontFace.imageOrientation + randRotation) % 360;

                    face.cubeOrder = cube.order;
                    face.cubeFaceId = cubeFrontFace.id;
                    face.cubeRotation = rotation;

                    faceStampNum = getFaceNumFromImage(cubeFaceFrontImage, rotation);
                    setFaceStamps(face, faceStampNum);

                    let backRotation = (cubeBackFace.imageOrientation + randRotation + 180 ) % 360;
                    faceStampBackNum = getFaceNumFromImage(cubeFaceBackImage, backRotation);
                    setFaceStamps(face, faceStampBackNum, useBack);
                }
            }

            return screen;
        }

        function getBackFace(frontFace) {
            let backFace = -1;

            switch (frontFace) {
                case _faceNumbers.Front:
                    backFace = _faceNumbers.Back;
                    break;

                case _faceNumbers.Back:
                    backFace = _faceNumbers.Front;
                    break;

                case _faceNumbers.Left:
                    backFace = _faceNumbers.Right;
                    break;

                case _faceNumbers.Right:
                    backFace = _faceNumbers.Left;
                    break;

                case _faceNumbers.Top:
                    backFace = _faceNumbers.Bottom;
                    break;

                case _faceNumbers.Bottom:
                    backFace = _faceNumbers.Top;
                    break;

                default:
                    alert('Invalid frontFace');
                    break;
            }
            return backFace;
        }

        function getFaceNumFromImage(faceImage, rotation) {
            let faceStampNum = 0;

            switch (faceImage) {
                case "blank":
                    faceStampNum = _goodFaces.blank;
                    break;

                case "block":
                    faceStampNum = _goodFaces.block;
                    break;

                case "triangle":
                    switch (rotation) {
                        case 0:
                            faceStampNum = _goodFaces.triangle_bottomLeft;
                            break;

                        case 90:
                            faceStampNum = _goodFaces.triangle_topLeft;
                            break;

                        case 180:
                            faceStampNum = _goodFaces.triangle_topRight;
                            break;

                        case 270:
                            faceStampNum = _goodFaces.triangle_bottomRight;
                            break;

                        default:
                            log('Invalid triangle rotation');
                            faceStampNum = 0;
                            break;
                    }
                    break;

                case "half":
                    switch (rotation) {
                        case 0:
                            faceStampNum = _goodFaces.rectangle_bottom;
                            break;

                        case 90:
                            faceStampNum = _goodFaces.rectangle_left;
                            break;

                        case 180:
                            faceStampNum = _goodFaces.rectangle_top;
                            break;

                        case 270:
                            faceStampNum = _goodFaces.rectangle_right;
                            break;

                        default:
                            log('Invalid rectangle rotation');
                            faceStampNum = 0;
                            break;
                    }
                    break;

                default:
                    log('Invalid face image');
                    faceStampNum = 0;
                    break;
            }

            return faceStampNum;

        }

        function setFaceStamps(face, faceNum, useBack) {
            let stamp;
            switch (faceNum) {
                case _goodFaces.blank:
                    face.setStampNum(0, 0, _triangleName.blank, useBack);
                    face.setStampNum(0, 1, _triangleName.blank, useBack);
                    face.setStampNum(1, 0, _triangleName.blank, useBack);
                    face.setStampNum(1, 1, _triangleName.blank, useBack);

                    break;

                case _goodFaces.block:
                    face.setStampNum(0, 0, _triangleName.block, useBack);
                    face.setStampNum(0, 1, _triangleName.block, useBack);
                    face.setStampNum(1, 0, _triangleName.block, useBack);
                    face.setStampNum(1, 1, _triangleName.block, useBack);

                    break;

                case _goodFaces.triangle_topLeft:
                    face.setStampNum(0, 0, _triangleName.block, useBack);
                    face.setStampNum(0, 1, _triangleName.topLeft, useBack);
                    face.setStampNum(1, 0, _triangleName.topLeft, useBack);
                    face.setStampNum(1, 1, _triangleName.blank, useBack);
                    break;

                case _goodFaces.triangle_topRight:
                    face.setStampNum(0, 0, _triangleName.topRight, useBack);
                    face.setStampNum(0, 1, _triangleName.blank, useBack);
                    face.setStampNum(1, 0, _triangleName.block, useBack);
                    face.setStampNum(1, 1, _triangleName.topRight, useBack);
                    break;

                case _goodFaces.triangle_bottomRight:
                    face.setStampNum(0, 0, _triangleName.blank, useBack);
                    face.setStampNum(0, 1, _triangleName.bottomRight, useBack);
                    face.setStampNum(1, 0, _triangleName.bottomRight, useBack);
                    face.setStampNum(1, 1, _triangleName.block, useBack);
                    break;

                case _goodFaces.triangle_bottomLeft:
                    face.setStampNum(0, 0, _triangleName.bottomLeft, useBack);
                    face.setStampNum(0, 1, _triangleName.block, useBack);
                    face.setStampNum(1, 0, _triangleName.blank, useBack);
                    face.setStampNum(1, 1, _triangleName.bottomLeft, useBack);
                    break;

                case _goodFaces.rectangle_left:
                    face.setStampNum(0, 0, _triangleName.block, useBack);
                    face.setStampNum(0, 1, _triangleName.blank, useBack);
                    face.setStampNum(1, 0, _triangleName.block, useBack);
                    face.setStampNum(1, 1, _triangleName.blank, useBack);
                    break;

                case _goodFaces.rectangle_top:
                    face.setStampNum(0, 0, _triangleName.block, useBack);
                    face.setStampNum(0, 1, _triangleName.block, useBack);
                    face.setStampNum(1, 0, _triangleName.blank, useBack);
                    face.setStampNum(1, 1, _triangleName.blank, useBack);
                    break;

                case _goodFaces.rectangle_right:
                    face.setStampNum(0, 0, _triangleName.blank, useBack);
                    face.setStampNum(0, 1, _triangleName.block, useBack);
                    face.setStampNum(1, 0, _triangleName.blank, useBack);
                    face.setStampNum(1, 1, _triangleName.block, useBack);
                    break;

                case _goodFaces.rectangle_bottom:
                    face.setStampNum(0, 0, _triangleName.blank, useBack);
                    face.setStampNum(0, 1, _triangleName.blank, useBack);
                    face.setStampNum(1, 0, _triangleName.block, useBack);
                    face.setStampNum(1, 1, _triangleName.block, useBack);
                    break;

                default:
                    log('Invalid faceNum in setFaceStamps');
                    break;
            }

        }
    </script>
    <script>
        "use strict";

        var _cachedTriangleString = [];
        function getTriangleString(triangleNum) {
            let triangleString = _cachedTriangleString[triangleNum];

            if (triangleString !== undefined) {
                return triangleString;
            }

            switch (triangleNum) {
                case _triangleName.blank:
                    triangleString = "";
                    break;

                case _triangleName.topRight:
                    triangleString = "NE";
                    break;

                case _triangleName.bottomRight:
                    triangleString = "ES";
                    break;

                case _triangleName.bottomLeft:
                    triangleString = "SW";
                    break;

                case _triangleName.topLeft:
                    triangleString = "NW";
                    break;

                case _triangleName.block:
                    triangleString = "NESW";
                    break;

                default:
                    log('invalid triangleNum in getTriangleString');
                    triangleString = "";
                    break;

            }

            //triangleString = "";
            //if ((triangleNum & TRIANGLE_BITS.North) == TRIANGLE_BITS.North) triangleString += "N";
            //if ((triangleNum & TRIANGLE_BITS.East) == TRIANGLE_BITS.East) triangleString += "E";
            //if ((triangleNum & TRIANGLE_BITS.South) == TRIANGLE_BITS.South) triangleString += "S";
            //if ((triangleNum & TRIANGLE_BITS.West) == TRIANGLE_BITS.West) triangleString += "W";

            _cachedTriangleString[triangleNum] = triangleString;

            return triangleString;
        }

        function calculateCenterPoint(xCol, yRow, stampX, stampY) {
            let centerPoint = new Point();

            centerPoint.x = (_size * xCol * _numStampsInRowOrCol) + (_size * stampX) + (_cubeSpace * xCol) + _half + _xOffset;
            centerPoint.y = (_size * yRow * _numStampsInRowOrCol) + (_size * stampY) + (_cubeSpace * yRow) + _half + _yOffset;

            return centerPoint;
        }

        function makeOutlinePoints(centerPoint) {
            let points = [];

            let centerX = centerPoint.x;
            let centerY = centerPoint.y;

            points.push(new Point(centerX - _half, centerY - _half));
            points.push(new Point(centerX + _half, centerY - _half));
            points.push(new Point(centerX + _half, centerY + _half));
            points.push(new Point(centerX - _half, centerY + _half));
            //points.push(new Point(centerX - _half, centerY - _half));

            return points;
        }

        function makeTrianglePoints(triangles, centerPoint) {
            let points = [];

            let centerX = centerPoint.x;
            let centerY = centerPoint.y;

            if (triangles.includes("N")) {
                points.push(new Point(centerX, centerY));
                points.push(new Point(centerX - _half, centerY - _half));
                points.push(new Point(centerX + _half, centerY - _half));
                //points.push(new Point(centerX, centerY));
            }

            if (triangles.includes("E")) {
                points.push(new Point(centerX, centerY));
                points.push(new Point(centerX + _half, centerY - _half));
                points.push(new Point(centerX + _half, centerY + _half));
                //points.push(new Point(centerX, centerY));
            }

            if (triangles.includes("S")) {
                points.push(new Point(centerX, centerY));
                points.push(new Point(centerX + _half, centerY + _half));
                points.push(new Point(centerX - _half, centerY + _half));
                //points.push(new Point(centerX, centerY));
            }

            if (triangles.includes("W")) {
                points.push(new Point(centerX, centerY));
                points.push(new Point(centerX - _half, centerY + _half));
                points.push(new Point(centerX - _half, centerY - _half));
                //points.push(new Point(centerX, centerY));
            }

            return points;
        }

        function drawShape(points, lineColour, fillColour, ctxIn) {
            let currPoint;

            let xPos;
            let yPos;

            let ctx = ctxIn || _ctx;

            if ((lineColour === undefined) || (lineColour == "")) lineColour = "black";
            if ((fillColour === undefined) || (fillColour == "")) fillColour = "clear";

            ctx.strokeStyle = lineColour;
            ctx.lineWidth = _lineWidth;
            ctx.beginPath();
            for (let pNum = 0; pNum < points.length; pNum++) {
                currPoint = points[pNum];
                xPos = currPoint.x;
                yPos = currPoint.y;

                if (pNum == 0) {
                    ctx.moveTo(xPos, yPos);
                } else {
                    ctx.lineTo(xPos, yPos);
                }
            }
            ctx.closePath();
            ctx.stroke();

            if (fillColour != "clear") {
                ctx.fillStyle = fillColour;
                ctx.fill();
            }
        }

        function Point(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
    </script>
    <script src="script/canvas.js"></script>
    <script src="cubes.js"></script>
    <script>
        "use strict";

        function findAllGroups() {
            let numCols = _mainScreen.getWidth();
            let numRows = _mainScreen.getHeight();

            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {

                    let face = _mainScreen.getFace(col, row);

                    for (let x = 0; x < _numStampsInRowOrCol; x++) {
                        for (let y = 0; y < _numStampsInRowOrCol; y++) {

                            for (let piece = 0; piece < _numPiecesInStamp; piece++) {

                                face.setStampVisited(x, y, piece, false);
                                face.setPieceColor(x, y, piece, "black");
                            }
                        }
                    }
                }
            }

            let grpData = new GroupData(numCols, numRows);

            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {

                    for (let x = 0; x < _numStampsInRowOrCol; x++) {
                        for (let y = 0; y < _numStampsInRowOrCol; y++) {

                            for (let piece = 0; piece < _numPiecesInStamp; piece++) {

                                grpData.isNewGroup = true;

                                let currStamp = new StampPos();
                                currStamp.col = col;
                                currStamp.row = row;
                                currStamp.x = x;
                                currStamp.y = y;
                                currStamp.piece = piece;

                                //console.log(currStamp);
                                findGroups(_mainScreen, grpData, currStamp);
                            }
                        }
                    }
                }
            }

            console.log("----------------");
            console.log(grpData);

            var elemOutout = document.getElementById("txtGroupData");
            elemOutout.value = JSON.stringify(grpData);

            for (let grp = 0; grp < grpData.groups.length; grp++) {
                let groupColor = _faceColors[grp];
                let currGroup = grpData.groups[grp];
                for (let stm = 0; stm < currGroup.groupStamps.length; stm++) {
                    let currStmp = currGroup.groupStamps[stm];
                    let face = _mainScreen.getFace(currStmp.col, currStmp.row);

                    face.setPieceColor(currStmp.x, currStmp.y, currStmp.piece, groupColor);
                }
            }

            _mainScreen.display(true);
        }

        function findGroups(screen, grpData, currStamp) {
            var face = screen.getFace(currStamp.col, currStamp.row);
            var visited = face.getStampVisited(currStamp.x, currStamp.y, currStamp.piece);

            if (!visited) {
                visited = true;
                face.setStampVisited(currStamp.x, currStamp.y, currStamp.piece, visited);

                var triangleString = face.getTriangles(currStamp.x, currStamp.y);
                var pieceNum = currStamp.piece;
                var currentTriangleIsOn = filterTrianglePos(triangleString, pieceNum);

                if (currentTriangleIsOn) {
                    grpData.addStampToGroup(currStamp);

                    var nextStampPosList = getNextStampPieces(currStamp, grpData.numCols, grpData.numRows);
                    if (nextStampPosList == null) return;

                    for (var stmp = 0; stmp < nextStampPosList.length; stmp++) {
                        var nextStamp = nextStampPosList[stmp];
                        if (!nextStamp) {
                            alert('Invalid next stamp');
                        }
                        findGroups(screen, grpData, nextStamp);
                    }
                }
            }

        }

        function getNextStampPieces(currStamp, maxCols, maxRows) {
            let nextStampPos = null;
            let nextStampPieces = [];

            let currPiece = currStamp.piece;

            switch (currPiece) {
                case TRIANGLE_POS.North:
                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.West;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.East;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.South;
                    if (currStamp.y > 0) {
                        nextStampPos.y--;
                    } else {
                        if (currStamp.row > 0) {
                            nextStampPos.row--;
                            nextStampPos.y = 1;
                        } else {
                            nextStampPos = null;
                        }
                    }
                    if (nextStampPos) nextStampPieces.push(nextStampPos);
                    break;

                case TRIANGLE_POS.East:
                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.North;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.South;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.West;
                    if (currStamp.x == 0) {
                        nextStampPos.x++;
                    } else {
                        if (currStamp.col < (maxCols - 1)) {
                            nextStampPos.col++;
                            nextStampPos.x = 0;
                        } else {
                            nextStampPos = null;
                        }
                    }
                    if (nextStampPos) nextStampPieces.push(nextStampPos);
                    break;

                case TRIANGLE_POS.South:
                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.East;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.West;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.North;
                    if (currStamp.y == 0) {
                        nextStampPos.y++;
                    } else {
                        if (currStamp.row < (maxRows - 1)) {
                            nextStampPos.row++;
                            nextStampPos.y = 0;
                        } else {
                            nextStampPos = null;
                        }
                    }
                    if (nextStampPos) nextStampPieces.push(nextStampPos);
                    break;

                case TRIANGLE_POS.West:
                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.South;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.North;
                    nextStampPieces.push(nextStampPos);

                    nextStampPos = clone(currStamp);
                    nextStampPos.piece = TRIANGLE_POS.East;
                    if (currStamp.x > 0) {
                        nextStampPos.x--;
                    } else {
                        if (currStamp.col > 0) {
                            nextStampPos.col--;
                            nextStampPos.x = 1;
                        } else {
                            nextStampPos = null;
                        }
                    }
                    if (nextStampPos) nextStampPieces.push(nextStampPos);
                    break;

                default:
                    log("Invalid piece");
                    nextStampPieces = null;
                    break;
            }

            return nextStampPieces;
        }

        function filterTrianglePos(triangleString, pos) {
            let triString = "notFound";
            switch (pos) {
                case TRIANGLE_POS.North:
                    triString = "N";
                    break;
                case TRIANGLE_POS.East:
                    triString = "E";
                    break;
                case TRIANGLE_POS.South:
                    triString = "S";
                    break;
                case TRIANGLE_POS.West:
                    triString = "W";
                    break;
                default:
                    log("Invalid triangle Pos");
                    break;
            }

            let foundPos = triangleString.indexOf(triString);
            let found = (foundPos >= 0);
            return found;
        }

        function GroupData(numCols, numRows) {
            this.currentGroup = 0;
            this.numCols = numCols;
            this.numRows = numRows;

            this.isNewGroup = true;

            this.groups = [];

            this.addGroup = function () {
                this.currentGroup++;
                this.isNewGroup = false;

                let newGroup = new Group(this.currentGroup);
                this.groups.push(newGroup);

                return newGroup;
            };

            this.addStampToGroup = function (currStamp) {
                if (this.isNewGroup) {
                    this.addGroup();
                }

                let newGroupStamp = clone(currStamp);
                let numGroups = this.groups.length;
                let currGroup = this.groups[numGroups - 1];
                currGroup.groupStamps.push(newGroupStamp);
            };

            this.checkIfStampInGroup = function (currStamp) {
                let numGroups = this.groups.length;
                let currGroup = this.groups[numGroups - 1];

                let found = currGroup.groupStamps.includes(currStamp);

                return found;
            };

            return this;
        }

        function StampPos(col, row, x, y, piece) {
            this.col = col || 0;
            this.row = row || 0;
            this.x = x || 0;
            this.y = y || 0;
            this.piece = piece || 0;

            return this;
        }

        function Group(num) {
            this.groupNum = num;
            this.groupStamps = [];
        }
    </script>
</head>
<body>
    <div>
        <span>Max Number of Rotations to skip BLANK faces:</span>
        <select id="selNumRotate">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5" selected="selected">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="11">11</option>
            <option value="12">12</option>
        </select>
        <button onclick="init();">Generate</button>&nbsp;
        <button onclick="findAllGroups();">Find Groups</button>
        <textarea cols="30" rows="2" id="txtScreenData"></textarea>
        <textarea cols="30" rows="2" id="txtGroupData"></textarea>
    </div>
    <div>
        <canvas id="canvasElem" width="750" height="375"></canvas>
    </div>
    <div>
        <canvas id="canvasElem2" width="750" height="375"></canvas>
    </div>
    <script>init()</script>

</body>
</html>
